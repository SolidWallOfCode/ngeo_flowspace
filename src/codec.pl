#!/usr/bin/perl -w
#Copyright 2005-2014 Network Geographics
#SPDX-License-Identifier: Apache-2.0
use strict;

use Getopt::Long;
use Pod::Usage;

my $MARK = "// Network Geographics Generated Code";
my $man = 0;
my $help = 0;
my $inFileName = '';
my $outFileName = '';
my $className = '';
my @args = @ARGV;

GetOptions('help|?' => \$help
          , 'inputFile=s' => \$inFileName
          , 'outputFile=s' => \$outFileName
          , 'class=s' => \$className
          , 'man'      => \$man
          ) or pod2usage(2);

pod2usage(1) if $help;
pod2usage(-exitstatus => 0, -verbose => 2) if $man;

$inFileName || die("An input file must be specified with the -inputFile option");
$outFileName || die("An output file must be specified with the -outputFile option");
$className || die("An class containing the enum must be specified with the -class option");

# Let's see if we can find the enum and its values
open IN, $inFileName or die('Failed to open input file ' . $inFileName . $! . "\n");

my $state = 0;
# 0 : outside any class
# 1 : inside enum class
# 2 : found enum
# 3 : found end of enum

my @values;
my $lastValue = 0; # value of last enum to compute non-specified enum values
my $enumName = "$className"; # the local name of the enum
my $qualifiedEnumName;    # the class qualified name of the enum

while (<IN>)
{
    # clip any comments first
    s!//.*!!;
    s!/[*].*!!;
    
    if ($state == 0)
    {
        if (/class[[:space:]].*$className/)
        {
            $state = 1;
        }
    }
    elsif ($state == 1)
    {
        if (/enum[[:space:]]/)
        {
            if (/enum[[:space:]]+([_[:alnum:]]+)/)
            {
                $enumName = "$1";
                $qualifiedEnumName = "$className\::$enumName";
            }
            $state = 2;
        }
    }
    elsif ($state == 2)
    {
        s/{//; # clip leading brace if present
        
        # loop over the comma separated elements
        for (split /,/)
        {
            if (/=/) # specified enum
            {
                if (/[[:space:]]*([[:alnum:]_]+)[[:space:]]*=[[:space:]]*(-?[[:digit:]]+)/)
                {
                    push @values, [ $1, $2 ];
                    $lastValue = $2;
                }
                elsif (/[[:space:]]*([[:alnum:]_]+)[[:space:]]*=/)
                {
                    print "Error: enum $1 does not a numeric constant for a value.\n";
                }
                else
                {
                    print "Error: enum value assignment |$_| in line $. is malformed.\n";
                }
            }
            elsif (/}/) # end of the enum
            {
                $state = 3; # clean up state so we can do error checking
                last; # only do one enum per run, so we're done
            }
            elsif (/^[[:space:]]+$/) # just ignore whitespace
            {
            }
            else # non-specified enum
            {
                if (/[[:space:]]*([[:alnum:]_]+)/)
                {
                    push @values, [ $1 , ++$lastValue ];
                }
                else
                {
                    print "Error: line $. in enum definition is malformed.\n";
                }
            }
        }
    }
}

# do some error checking to verify that we have a good chance of having loaded up the
# enum values correctly
die("Fatal: Failed to locate enumeration class $className in file $inFileName.\n") if $state == 0;
die("Fatal: Failed to locate enumeration in enumeration class $className in file $inFileName.\n") if $state == 1;
die("Fatal: Failed to locate end of enumeration in enumeration class $className in file $inFileName.\n") if $state == 2;

if (! open OUT, "$outFileName")
{
    open OUT, "> $outFileName" or die("Fatal: Failed to create output file $outFileName : $!\n");
}
else
{
    # file exists, verify that we can trash it
    $_ = <OUT>;
    if (!($_ && m!^$MARK!))
    {
        die("Fatal: Output file $outFileName exists and was not generated by this program\n");
    }
    if (! open OUT, "> $outFileName") # truncate the file. Can't get truncate() to work
    {
        die("Fatal: Unable to truncate output file $outFileName - $!\n");
    }
}
print OUT "$MARK\n";
print OUT <<CODE;
// Generated by: perl.exe codec.pl @args\n
// This file requires the following includes:
//    <boost/bind.hpp>
//    <algorithm>
//    <bijection.h>
CODE

# need to check for generated file tag and force create in a second pass.
# i.e. if not exist, then ok otherwise check for generated file tag

my $invalid = "$className()"; # default invalid value

my $TAB="    ";    # four spaces, one tab indent

# need to do the enums in sorted order
@values = sort { $a->[1] <=> $b->[1] } @values;

## Set up the bijection
my $biEnumIntName = uc($className) . '_TABLE';
my $biEnumStringName = uc($className) . '_IO_TABLE';
my $initializerClass = $className . '_table_initializer';
my $initialierInstance = uc($initializerClass);
print OUT <<BIJECTION_PRE;
namespace {
    ngeo::bijection<$qualifiedEnumName, int> $biEnumIntName;
    ngeo::bijection<$qualifiedEnumName, std::string> $biEnumStringName;
    const struct $initializerClass {
        $initializerClass()
        {
BIJECTION_PRE

for (@values) {
    print OUT ('            ', $biEnumIntName, '.insert(', $className, '::', $_->[0], ',', $_->[1], ");\n");
    print OUT ('            ', $biEnumStringName, '.insert(', $className, '::', $_->[0], ', "', $_->[0], '");', "\n");
}

print OUT <<BIJECTION_POST;
            $biEnumIntName.set_default(-1);
            $biEnumIntName.set_default($qualifiedEnumName());
        }
    } ICMP_TYPE_TABLE_INITIALIZER;
}
BIJECTION_POST

## Generate the encode method
print OUT <<CODEC;

$qualifiedEnumName $className\::encode(int i)
{
    return $biEnumIntName\[i];
}

int $className\::decode($enumName x)
{
    return $biEnumIntName\[x];
}
CODEC

## Set up the IO operators
print OUT <<IO_OP;

std::ostream& operator << ( std::ostream& s, $qualifiedEnumName const& x )
{
    return s << x.m_value;
}

std::istream& operator >> ( std::istream& s, $qualifiedEnumName & x )
{
    if (s >> std::ws) {
        int c = s.peek();
        if (isdigit(c)) {
            int i;
            if (s >> i >> std::ws) {
                x.m_value = i;
            }
        } else if (isgraph(c)) {
            std::string name;
            if (s >> name >> std::ws) {
                std::transform(name.begin(), name.end(), name.begin(), toupper); // force upper case
                p.m_value = IpProtocolNames.value(name, ip_protocol::INVALID);
            }
        } else
	    s.setstate(std::ios::failbit);
    }
    return s;
}
IO_OP

__END__
## String name table for stream operators
print OUT "\nstatic char const* const ${nameArrayVar}[] =\n{\n";
print OUT ("$TAB\"", $_->[0], "\",\n") foreach @values;
print OUT "};\n\nstatic size_t const $nameArrayCountVar = sizeof($nameArrayVar)/sizeof(*$nameArrayVar);\n";

# Generate the output stream operator
print OUT "\nstd\::ostream& operator << ( std\::ostream& s, $qualifiedEnumName const& v )\n{\n";
print OUT ( $TAB, "int i = $className\::decode(v);\n"
          , $TAB, "return s << ((0 <= i &&  i < $nameArrayCountVar) ? ${className}_${enumName}_name[i] : \"INVALID\");\n}");

# Input stream operator
print OUT <<CODE;
\n
std::istream& operator >> ( std::istream& s, $qualifiedEnumName & v)
{
    std::string name;
    if (s >> std::ws >> name >> std::ws ) {
        std::transform(name.begin(), name.end(), name.begin(), toupper); // force upper case
        char const* const* spot = std::find_if($nameArrayVar, $nameArrayVar + $nameArrayCountVar, boost::bind(strcmp, _1, name.c_str()));
        if (spot != $nameArrayVar + $nameArrayCountVar) {
            v = ${className}::encode(static_cast<int>(spot - $nameArrayVar));
        } else {
            s.setstate(std::ios::failbit);
        }
    }
    return s;
}

CODE

__END__

=head1 NAME

    codec - Generating method implementations for encoding and decoding enums

=head1 SYNOPSIS

    sample [options] [file ...]
     Options:
       -inputFile       the header file with the class definitions
       -outputFile      the file to write
       -class           the enum wrapper class
       -help            brief help message
       -man             full documentation

=head1 OPTIONS

=over 8

=item B<-help>

Print a brief help message and exits.

=item B<-man>

Prints the manual page and exits.

=back

=head1 DESCRIPTION

B<This program> will read the given input file(s) and do someting
useful with the contents thereof.

=cut
